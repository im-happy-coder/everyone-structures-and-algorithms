# 1.1 자료 구조

## 자료구조의 4가지 기본 방법

- 읽기: 배열의 특정 인덱스를 찾는다 (인덱스 2에 들어 있는 물건을 찾는게 배열의 읽기이다.)
컴퓨터는 딱 한 단계로 배열에서 읽을 수 있다.
컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.
그 이유는 배열을 할당할 때 어떤 메모리 주소에서 시작하는지도 기록해 둔다. 그래서 배열의 첫 번째 원소를 찾으라고 요청하면
적절한 메모리 주소로 바로 가서 찾는다.(마치 오른손 새끼 손가락 들어보라고 할 때 우리는 오른손 새끼 손가락을 일일이 찾지 않고 바로 들 수 있는 것과 같다.)

배열의 인덱스는 0부터 시작하면 0의 메모리주소는 1010이다.
인덱스 3은 인덱스 0부터 정확히 세 슬롯 뒤에 있다.
따라서 인덱스 3을 찾으려면 1010+3인 1013 메모리 주소로 간다.

- 검색: 자료 구조 내의 특정 값을 찾는 것이다.("dates"가 식료품 목록에 들어 있는지)
컴퓨터는 모든 메모리 주소에 한 번에 접근 가능하지만 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.

- 삽입: 자료 구조에 새로운 값을 추가 하는 것이다.
배열의 삽입의 최악의 시나리오는 맨 앞에 삽입할 때다. 배열의 앞에 삽입하면 배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 하기 때문이다.
다시 말해 원소 N개를 포함하는 배열에서 최악의 시나리오일 때 삽입에는 N+1단계가 걸린다.
N개의 원소를 전부 이동시키고 끝으로 실제 삽입 단계를 실행해야 하기 때문이다.

- 삭제: 자료 구조에서 값을 제거하는 것이다.
삽입과 비슷하게 원소 삭제에서 최악의 시나리오는 배열의 첫 번째 원소를 삭제하는 것이다.
이렇게 되면 인덱스 0이 비게 되고 남아 있는 모든 원소를 왼쪽으로 이동시켜 빈 공간을 채워야 한다.

# 1.3 속도 측정

연산이 "빠른가"가 아닌 얼마나 "많은" 단계가 필요한지 논해야 한다.
왜? 같은 컴퓨터라도 어떤 연산은 5초가 걸리고, 구형 컴퓨터에서는 더 오래 걸릴 수 있다.
즉 시간연산은 수행하는 하드웨어에 따라 속도가 항상 다르다.

연산의 속도는 시간 복잡도 측정으로 알려져 있고, 속도와 시간복잡도, 효율성, 성능이라는 용어는 같은 의미로 사용하겠다.
네 용어 모두 주어진 연산에 걸리는 단계 수를 나타낸다.

## 1.8 집합: 단 하나의 규칙으로 효율성이 달라진다

집합은 중복 값을 허용하지 않는 자료 구조다.
집합은 중복 데이터가 없을 때 유용하다.
집합은 읽기, 검색, 삭제가 배열과 동일하다.

삽입만큼은 배열과 다르다.
컴퓨터는 배열이나 집합의 셀에 어떤 값이 들어 있는 지 바로 알 수 없다.
삽입하려는 값이 집합에 이미 있는지부터 먼저 "검색"해야 하낟.
따라서 모든 삽입에는 검색이 우선이다.

집합의 끝에 삽입하려면 원소 N개에 대해 최대 N+1 단계가 필요하다.
값이 집합에 없음을 확인하는 데 N단계의 검색을, 이어서 실제 삽입에 1단계를 쓰기 때문이다.

값을 집합의 맨 앞에 삽입하는 최악의 시나리오일 때 컴퓨터는 셀 N개를 검색해서 집합이 그 값을 포함하지 않음을 확인한 후,
또 다른 N단계로 모든 데이터를 오른쪽으로 옮겨야 하며, 마지막 단계에서 새 값을 삽입해야 한다.
총 2N + 1단계다. 맨 앞에 삽입하는 데 N+1단계 밖에 걸리지 않는 일반적인 배열과 대조된다.

중복 데이터가 없는 경우는 집합이 답이다.


## 1.9 마무리

자료 구조의 성능 측정은 연산에 필요한 단계 수를 구하는 게 핵심이다.
프로그램이 대용량 트래픽에 감당 하려면 코드의 최고속도와 성능을 내게끔 하는 게 핵심이다.

## 1.10 연습 문제

1. 원소 100개를 포함하는 배열이 있을 때, 다음 연산에 걸리는 단계 수를 계산하라.

    a. 읽기
    b. 배열에 들어 있지 않은 값 검색
    c. 배열 맨 앞에 삽입
    d. 배열 맨 뒤에 삽입
    e. 배열 맨 앞에서 삭제
    f. 배열 맨 뒤에서 삭제


2. 원소 100개를 포함하는 배열 기반 집합이 있을 때, 다음 연산에 걸리는 단계 수를 계산하라.
    
    a. 읽기
    b. 배열에 들어 있지 않은 값 검색
    c. 배열 맨 앞에 새 값 삽입
    d. 배열 맨 뒤에 새 값 삽입
    e. 배열 맨 앞에서 삭제
    f. 배열 맨 뒤에서 삭제

3. 일반적으로 배열에서 검색 연산은 주어진 값의 첫 인스턴스를 찾는다. 하지만 주어진 값의
   모든 인스턴스를 찾을 때가 있다. 예를 들어 배열에 "apple"이 몇 번 나오는지 세고 싶다.
   모든 "apple"을 찾는 데  몇 단계가 걸릴까? N에 답하라.